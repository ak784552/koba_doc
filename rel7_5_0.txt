coal 7.5.0の機能改善およびバグｆｉｘ
********************************
*         機 能 改 善          *
********************************
<2025.03.24>
(1)有理数をサポートした。
   --> makefile, cl_cmpt_rational.c, cl_cmpt_math.c, cl_gx_func_bexp.c, clprdeftype.c,
       cltrbexp.c, cl_conv_const_n.c, clconst.h

<2025.03.25>
(2)m_is_mpa1(), m_mod2()を追加した。
   --> akxmpa.c, akxlib.h

<2025.03.26>
(3)akxg_sosu_next(), akxg_sosu_next_tbl()を追加した
   --> akxgmath.c, akxlib.h

<2025.04.12>
(4)_b_search_mpa(), akxg_sosu_over_by_tbl(), akxg_sosu_chk_mpa_by_tbl(),akxg_sosu_next_mpa_tbl(),
   akxg_sosu_next_mpa(), akxg_sosu_over_mpa_by_tbl()を追加した
   --> akxgmath.c, akxlib.h

<2025.05.19>
(5)_cvl()のオーバーフローチェックに、INTベースオプションを追加した。
   -->akxconvn.c, cl_conv_const_n.c

<2025.05.20>
(6)64ビット環境では、intオーバーのときは、longに変更するようにした。
   このために、_cvl()のINTベースオプションは、なしに戻し、intオーバーのチェックとlongへの変更は、
   cl_cvn10()で行うようにした。
   -->akxconvn.c, cl_conv_const_n.c

(7)64ビット環境では、型指定なしのint/uint変数を"++"したときに、オーバーフローのときは、
   long/ulongに変更するようにした。
   --> cl_gx_compute.c

<2025.05.27>
(8)会話モードでのサブコマンドを以下のように見直した。
   /treeを廃止し、/のみのときは、前回の実行を再度実行するようにした。また、/ historyのときは、
   入力履歴域に保存された文からコマンドtreeを生成し直し、実行するようにした。
   --> cl_path.c

<2025.06.08>
(9)m_normalize10()とm10w_print_debug()を追加した。
   --> akxmpa.c

<2025.06.09>
(10)プリントオプション(flgs)を引数で渡していない関数でのデータ出力については、一時的に、
   実行時オプションを設定してプリントオプションを効かせていたが、引数(opt_edit)で渡すようにした。
   また、プリントフォーマットの%rでもプリントオプションが効くようにした。
   --> cl_user_func.c, cl_cmpt_string.c, cl_func_file.c, cl_const.h

(11)[f]putline()で、区切り文字オプションを有効にしたときは、その文字で区切られるようにした。
    区切り文字のデフォルトを/cとした。
    また、データ指定範囲データが展開されるようにした。
   --> cl_func_file.c

<2025.06.12>
(12)parm_to_char()の*p1とp1_lenの扱いを解り易くした。
    また、parm_to_char2(),parm_to_char2_opt_edit(),cl_get_info_str()の引数にp1_lenを追加した。
   --> cl_cmpt_string.c

<2025.06.13>
(13)プリントオプションの'/'から始まる設定を繰り返し指定できるようにした。
   --> cl_user_func.c

<2025.06.18>
(14)cl_set_array()で、配列、リスト、データ並びのデータ指定を可能とし、名前付き引数MAX_LAYERを
    設定した。
    また、cl_set_array_ix()をcl_set_array_ix2()として、出力と入力のppParm[]を分けた。
   --> cl_gx_ret_set.c, cl_gx_rep_prm_set.c

<2025.06.22>
(15)ハッシュ関数に、キー値を前方一致で検索する関数(akxs_xhashn2_like)を追加した。
    また、登録位置を指定してキーを削除する機能('E')を追加した。
   --> akxshash.c

<2025.06.25>
(16)ISに'C'(文字コード)を、TOに'CN'(文字コードの名称に変換)を追加した。
   --> cl_cmpt_is.c, cl_cmpt_to.c

<2025.06.26>
(17)akxs_ino_mem_opt()のoptがcode_typeのみの高速版(akxs_in_mem_type())を追加した。
   --> akxstring.c

<2025.06.27>
(18)akxs_ino_mem_opt()で、targetが長いと遅くなる原因がakxmbncmp_type_opt()で、akxqmlen_type()を
    呼んでいることが判明したため、akxmbncmp_type_opt()を文字数も渡すakxmbncmp_type_opt_m()にし、
    akxs_ino_mem_opt()では、mtarとmstrも渡すようにした。
    また、akxs_in_mem_type()を使わなくても良くなった。
   --> akxstring.c

<2025.06.28>
(19)以下のように、組み込み関数の最大パラメータ数をチェックできるようにした。
    pot->resv>0のときに、pot->resv-1を最大パラメータ数としてチェックする。
   --> cl_gx_func_bexp.c

<2025.07.04>
(20)比較文字列を内側で回す文字サーチ関数(akxs_in_mem_str_inner())を追加し、
    (opt & 0x80)がONのときは、akxs_in_mem_str()を呼ぶようにした。逆に、
    akxs_in_mem_str()は、(opt & 0x80)がONのときは、akxs_in_mem_str_inner()を呼ぶようにした。
   --> akxstring.c

(21)関数INSTRCHARS()を追加した。
   --> cl_cmpt_comp.c, clprot.h

(22)akxs_in_mem_str()では、大文字小文字無視、半角全角無視の比較は、akxmbncmp_type_opt_m()の
    中で行っているが、対象文字列を1文字ずらす度に対象文字列に対して、最長比較文字列の文字数分の
    変換を行っているため、変換の効率が悪い。
    そこで、akxmbncmp_type_opt_m()では、変換しないことにし、akxs_in_mem_str()で、最初に、
    比較文字列と対象文字列の先頭の比較文字列数分を変換しておき、後は、1文字ずらす度に、
    比較文字数分が変換されているように、比較文字数分の次の文字のみを変換するようにした。
    これでも、1文字ずらすために、半角全角変換が必要なため、半角全角変換は2回行われる。
   --> akxstring.c, akxcode.c, akxlib.h

<2025.07.05>
(23)以下により、全角変換と大文字変換の回数を文字数分の1回にした。
    ・半角全角無視で対象文字列に半角カナの濁点、半濁点がない用の関数
      akxs_ino_mem_opt_no_kanad()を作成した。(大文字小文字無視もこれで実行する))
    ・akxs_ino_mem_opt()では、上記以外で、変換があるときは、最初に、対象文字列と比較文字列の
      両方を変換済みにした。
   --> akxstring.c, akxlib.h

<2025.07.13>
(24)for to stepの構文で、stepの後ろのパラメータがなくても多くてもエラーを出すようにした。
   --> cltrloop.c

<2025.07.15>
(25)組み込み関数実行前のNULLチェックで、エラーメッセージを出すようにした。
    _get_array_info_ref()の最初で、NULLパラメータとNULL値のときは、エラーとした。
   --> cl_gx_func_bexp.c, cl_gx_rep_set.c

<2025.07.16>
(26)ARRAYCLR()等で、A,R以外のチェックが、cl_get_array_index_tbl_ref()の中で呼んでいる
    cl_get_parm_bin()まで行われていないので、cl_array_ope_opt()で行われるように以下のように
    修正した。
    ・ARRAYCMP()は、ok_opt=0x02 | 0x08 | 0x1000
    ・他は、ok_opt=0x02
   --> cl_gx_rep_set.c

<2025.07.19>
(27)以下のように関数名を変更した。また、cl_is_null()を追加した。
   --> cl_null_data()        ==> cl_null_char()
       cl_is_null_data_sub() ==> cl_is_null_char_sub()
       cl_is_null_data()     ==> cl_is_null_char()

<2025.07.22>
(28)cl_is_null()では、オプション１が0x40のときは、cl_is_null_chk_parm()を呼んで、NULL_PARMと
    NULL_CHARのときに、NULL値と判定していた(NULL値の判定がない)が、オプション１に0x80を追加し、
    cl_is_null_chk_parm()を使用しないで、cl_is_null()の中で、判定するようにした。
   --> clfunc.c

<2025.07.29>
(29)akxtgwnsl()で、opt=0x1000のときは、引用符で始まらないワード中の引用符を区切りとしないようにした。
   --> akxlib.c

<2025.08.07>
(30)システム変数に、TRUEとFALSEを追加した。
   --> cl_conv_sysvar.c, clglobal.c, clconst.h

(31)「定数(x)への代入はできません。」のエラーメッセージで、システム変数のときは、
    「システム変数(x)への代入はできません。」とした。
   --> cl_gx_compile.c, clmessage.c

<2025.08.09>
(32)オプション２４=0x100のときは、システム変数の予約語チェックでは、大文字小文字を
    問わないようにした。
   --> cl_anal_parm.c, cl_conv_parm

<2025.08.14>
(33)全角半角変換で"＼"を"\"に変換するようにした。
   --> akxcode.c

<2025.08.15>
(34)ログ出力で、複数I/Oに出力するときは、コード変換が1回で済むようにした。
   --> akxalog.c

<2025.08.16>
(35)DEFINEで、複数データを設定するとき、"{}"でも良いようにした。
   --> clprdef.c

<2025.08.22>
(36)length()で、配列、リスト、データ並びのときは、要素数を返すようにした。
   --> cl_cmpt_is.c

(37)concat()関数で、連結する文字列の間に挿入する文字列を指定する SEP==>'xxx' を追加した。
    それに伴い、concat2(),cl_gx_bexp2()を作成し、引数をppParm[]ベースに変更した。
    また、cl_cmpt_string())の引数をppParm[]ベースに変更した。
   --> cl_cmpt_string.c, cl_gx_compute.c, cl_gx_func_bexp.c

(38)リスト、データ並びにインデックス参照のとき、負のときは、末尾からの指定とした。
   --> cl_gx_rep_set.c, cl_gx_exp_imd.c

(39)countv()関数で、opt=0x02のときは、配列の定義長を返すようにした。
   --> clfunc.c

<2025.08.24>
(40)POP()関数を追加した。
   --> clconst.h, cl_gx_func_bexp.c, cl_gc_ret_set.c

<2025.08.25>
(41)RANDOM()関数を追加した。
   --> clconst.h, cl_gx_func_bexp.c, cl_gc_ret_set.c

<2025.08.29>
(42)集約の'|'、'&'、'^'の結果がユニークになるようにした。
    また、'-'と'+'に同じ機能で、結果がユニークになる演算子'/'と'*'を追加した。
   --> cl_cmpt_logic.c, cl_gx_rep_prm_set.c

<2025.09.06>
(43)POP()関数の引数に、POPする数、間隔、名前付きOPTを追加した。
   --> cl_gx_rep_sep.c

<2025.09.15>
(44)親の設定済み最大インデックス位置を子に反映させる関数ADJUST()を追加した。
   --> cl_gx_func_bexp.c, cl_cmpt_logic.c, clconst.h

<2025.09.18>
(45)SUBSTRの開始位置または文字数が負のとき、調整する関数mod_pos_len()を追加し、
    SUBSTR()とドット指定に適用した。
   --> cl_cmpt_comp.c, cl_cmpl_string.c, clprot.h

<2025.09.20>
(46)二項演算でデータＩＤが合わなかったときのエラーメッセージを改善した。
   --> cl_gx_compute.c, clmessage.c

<2025.09.23>
(47)ソースファイルのcl_gx_compile.cからobj実行を分離した、合わせて、コンパイル関連の
    関数をcl_gx_compile.cにまとめた。
   --> cl_gx_compile, cl_gx_exp_imd.c, cl_gx_ex_obj.c, clprot.h

<2025.09.25>
(48)EXECコマンドで手続き種別'IP','EP','SC'を指定なしで実行できるようにした。
   --> cpprexec.c

<2025.09.27>
(49)マップインデックスの位置指定を配列の先頭からの相対位置に統一した(先頭が0)。
   --> cl_array.c, cpprproc.c, clmessage.c

(50)配列のデータ配置をFORTRAN形式をデフォルトにした。
   --> cl_array.c

<2025.09.28>
(51)配列定義のindex[3](オフセット)が1から始まっていたものを0からに変更した。
   --> cl_array.c, clfunc.c, clprdef.c, cl_user_func.c, cl_gx_rep_set.c, cl_gx_rep_prm_set.c,
       cl_gx_ex_obj.c, cl_cmpt_string.c, cl_cmpt_math.c, cl_cmpt_logic.c, clsort.c,
       clprdeftype.c, cllog.c, clfuncfile.c

<2025.10.08>
(52)関数AGG()を追加した。
   --> cl_gx_func_bexp.c, clconst.h

(53)left(),right()で、配列、リスト、データ並びを処理できるようにした。
   --> cl_gx_func_bexp.c

<2025.10.11>
(54)関数INSERT()を追加した。
   --> cl_gx_func_bexp.c, cl_cmpt_logic.c, clconst.h

<2025.10.18>
(55)関数VAR_LIST()を追加した。
   --> cl_gx_func_bexp.c, cl_cmpt_logic.c, cl_user_func.c, clconst.h, clprot.h

<2025.11.1>
(56)for each xでxに対象データの値を設定する機能とオプション22を追加した。
    従来のオプション22は、オプション15に移した。
   --> clprloop.c

<2025.11.2>
(57)for eachに、eachv、eachiを追加した。
   -->cltrbexp.c, cltrloop.c, clprloop.c, clconst.h

<2025.11.4>
(58)リストまたはデータ並びの要素がないいときは、空のリストまたはデータ並びとした。
   --> cl_gx_ret_set.c, cl_gx_func_bexp.c

<2025.11.13>
(59)##if 0 等でのスキップ処理を、_proc_pragma()では、フラグ(giPREPRO_SKIP)を立てるのみのし、
    スキップ処理は、lex()本体で行うようにした。これは、スキップ処理中でも、コメント、
    引用符等を識別する必要があるため。
   --> cllex.c

<2025.11.24>
(60)CSTRのキャストを使用できるようにした。
   --> cl_compute.c, cl_gx_compile.c

<2025.11.25>
(61)データ型にUCHAR,SHORT,USHORT,BYTEを、関数とキャストにCUCHAR,CSHORY,CSHORT,CBYTEを追加した。
   --> clconst.h, cl_gx_compute.c, cl_gx_func_bexp.c, cltrbexp.c

<2025.12.02>
(62)コメント内、引用符内、##if 0等での処理を以下の様にした。
    (1)コメント内
       "/*","*/","//"以外は、無視する。
    (2)引用符内
       開始引用符以外は、無視する。
    (3)##if 0等の中(スキップモード中)
       "#"以外は、その行をスキップする。
   --> cllex.c, colmain.c, clprimport.c

<2025.12.03>
(63)オプションのデフォルト値をadd/delするCの関数cl_set_opt_add_del()を追加した。
    関数GETARGS()に適用した。
   --> cl_cmpt_string.c

<2025.12.07>
(64)condListにrbuf_lenを追加し、スクリプト読み込み処理でのバッファ長をこれに設定するようにした。
    cl_get_str()では、BUFLENを上記の1/2に変更した。
   --> cllexfnc.c, cllex, cllocal.h

(65)スクリプト読み込み処理において、1行がBUFLENを超えるときにマルチバイト文字が、
    行終わりに掛かるときの処理を見直した。
   --> cllex.c

<2025.12.09>
(66)##pragmaで、スクリプトの文字コードを指定できるようにした。
    Cの関数 akxt_set_xml_attr()とakxt_get_attr_val() を追加した。
   --> akxgetstpl.c, akxlib.h, cllex.c

<2025.12.20>
(67)変数のスコープにブロックを追加した。また、スコープに関するoptのdefine値を整理した。
   --> cl_conv_parm.c, cl_gx_compile.c, clprdef.c, cl_proc_bexp.c, clglobal.c, cltrbexp.c,
       cl_const.h, cl_prot.c

<2025.12.21>
(68)for eachの要素用変数が、ループを開始する前に作成されているので、ループを開始するときに
    ブロック変数で作成するようにした。
    また、eachkでも要素用変数にインッデックスを設定するようにした。
   --> cpprloop.c, cptrbexp.c


<2025.12.25>
(69)「マップインデックスの位置指定を配列の先頭からの相対位置に統一した(先頭が0)。」
    これにしたが、マップ位置は、配列定義上のインデックスの方が分かり易いので、そうした。
   --> clprdef.c, clprproc.c, clconst.h

<2025.XX.XX>
(70)
   -->

********************************
*           Bug fix            *
********************************
<2025.03.26>
(1)3.5r/10が、「１０進小数点数[3.5r]の指定が誤っています(rc=-15)。」となる。
   [原因]atrが2と4のときは、ULIRを返しているが、3.5のときは、atr=8となっているため、
         UILRが返っていない。
   [措置]atr=8でもULIRを返すようにした。
   --> akxconv.c

<2025.04.10>
(2)a=32767.0;b=16384.0;a/b が 1.0... になる。
   [原因]1桁目を処理した後、a=16383.0で、anm=163 bnm=163 となっているため、anmが16383にならず、
         また、d=1となるため、md[d]がそのまま使われ、正しい引き算になっていなかった。
   [措置]anm=bnmでもanmが16383になるようにし、d=100(RADIX)のときは、d=99(RADIX-1)とするようにした。
   --> akxmpa.c

<2025.04.23>
(3){}の形式の関数を実行したとき、retvalに設定してあるpInfoParmWの内容がRETURN時に不正になる。
   [原因]pInfoParmWはオート変数を使っているため、関数実行でnodeに戻る場合、エリアが失われてしまう。
         {}形式でないときは、pInfoParmWをmallocしたものに置き換えているため、エリアが失われることはない。
   [措置]{}の形式かどうかの判別をやめ、pInfoParmWをmallocしたものに置き換える処理を関数化した上で、
         ユーザ定義関数を実行するときのみ、この関数を呼ぶようにした。
         なお、cl_gx_func_method()の中では、pInfoParmW->pi_idに'F'をセットし、このときのみ、
         上記関数を実行するようにした。
      /************ retvalは関数からreturnするときのみ使用するため、これは必要ない気がする
         また、上記関数では、pInfoParmWのエリア用に"$関数名"の変数を作成しているが、この変数の
         後ろに通番を付けるようにした。これは、一つの式の中で同じ関数が呼ばれても、pInfoParmWの
         エリアが同じにならないようにするためである。
       ************/
   --> cl_gx_func_bexp.c, cl_execute_proc.c

<2025.05.12>
(4)オプション20で仮数桁数とゼロサプレスを指定してもdouble型のときは、0.0がゼロサプレスされない。
   [原因]仮数桁数が指定なしでゼロサプレス指定があるとき、0.0を"0.0"としている。
   [措置]ゼロサプレス指定があるときは、0.0を"0.0"とするようにした。
   --> cl_cmpt_string.c

<2025.05.14>
(5)coal_clasicで、test_math.clを実行すると、print "30 ** 9" が、"演算子30が誤っている"の
   エラーになる。
   [原因]パラメータが1つのときは、cl_getitems()を使って、項目に分解しているが、項目データを
         格納するエリアworkの長さをパラメータ長(len)+1にしている。
         cl_getitems()では、項目データをnull終端にして、workに詰めている。このとき、akxtgwnsl()、
         この中で呼んでいるakxwdmax_chkm()を使って、項目の分解とworkへの設定を行っている。
         このケースでは、"9"を取りに行ったときには、akxwdmax_chkm()の引数は、lmax=1,l=0,m=1で
         エリアが足りているかの判定を"(l<lmax-m)"としているため、"9"が設定されていない。
         結果として項目数が２となり、30が単項演算子と見なされエラーとなった。
   [措置]akxwdmax_chkm()判定を"(l+m <= lmax)"とした。akxwdmax_chk()、akxwdmax_chk2()も同様に修正。
   --> akxgetstpl.c

<2025.05.19>
(6)型指定なしの整数変数の"++"、"--"で、オーバーフローしても、元の値のままになる。
   [原因]オーバーフローするときは、演算していない。
   [措置]オーバーフローしたときは、DECに変換するようにした。また、オプションも考慮するようにした。
   --> cl_gx_compute.c

<2025.05.20>
(7)64ビット環境では、型指定uint属性のUINT_MAX値を"++"すると0になる。
   [原因]uintをulongにして"++"しているが、uintに戻すときに、cl_set_parm_bin()を使い、ulong値を
         そのまま渡している。cl_set_parm_bin()は、int値をもらう定義のため、下位32ビットが取られ、
         0となった(ulong値が0x0000000100000000となっているため)。
   [措置]int変数に代入してから、cl_set_parm_int()を呼ぶようにした。
         また、cl_set_parm_int()では、long値に代入して、cl_set_parm_long()を呼ぶようになっていたが、
         long値の前半分にint値が入るようにした。
   --> cl_gx_compute.c cl_conv_const_n.c

<2025.06.11>
(8)parm_to_char(),parm_to_char_temp()を呼ぶ前に、文字列を戻すポインタ(p1)を初期化していないヶ所がある。
   [原因]設定忘れ。
   [措置]p1 = NULLを入れた。
   --> cl_conv_arg.c, cl_gx_compute.c, cl_cmpt_comp.c, clprdef.c, cl_cmpt_to.c, cl_cmpt_string.c

<2025.06.13>
(9)--p1,1で、lprint()を実行してもPRINTOUT()の形式で出力されない。
   [原因]cl_func_print()で処理しているが、D_FUC_FPRINT以外は、D_FUC_ELWRITE1で出力しており、
         PRINTOUT(),ERROUT()を呼ぶ処理がない。
   [措置]cl_func_print()の最初で、PRINTオプション(flgs)の処理をしているが、_func_print_sub()に
         渡しておらず、_func_print_sub()では、flgsの処理を独自で行っているため、flgsの初期化を
         cl_func_print()に移し、_func_print_sub()に渡すようにした。
         その上で、PRINTOUT(),ERROUT()を呼ぶ処理を追加した。
         また、_func_print_sub()は、cl_func_sprint()でも呼んでいるため、flgsの処理を同様にした。
   --> cl_user_func.c

<2025.06.22>
(10)array b 10 = a[2..5]; の後で、print b; print *b を実行すると、aは無効にならないが、
    print b *b;を実行すると、aが無効のエラーになる。
   [原因]配列の範囲指定インデックスでは、temp域に配列定義とデータを作成しており、その行の実行が
         終わるとtemp域は、無効になるが、printで、この配列の有効性をチェックしたときのtemp域の
         内容により無効になったり有効になったりしている。
/**********************************************************************************************
   [措置]配列定義を保存する変数をローカルに作成し、temp域が無効になっても、配列定義を参照できる
         ようにした。
         そして、この行の実行が終わって次の行を実行するときに、この配列定義のpi_idをクリアして、
         無効判定になるようにした。このときに、この変数を削除するために、ハッシュ関数に、'E'を
         追加したが、配列定義域がfree()されるため、変数は削除できない。
   --> cl_array.c, clnode.c
**********************************************************************************************/
   [措置]配列の範囲指定インデックスで取得したデータを保存する配列を通常のローカル変数で
         作成し、配列が無効にならないようにした。
         変数名は、"$$range_array%08x"、%08xは、インデックス情報(tdtArrayIndex)のアドレス。
   --> cl_array.c

<2025.07.19>
(11)コマンドライン オプション -oで、n=xxxxでない指定をすると値が設定されない。
   [原因]set_dbgopt_argv()で、n=xxxxでないときに、iADD_DELが未設定のまま、set_flg[ii]に代入している。
   [措置]iADD_DEL = cl_get_add_del(&p,&len);を追加した。
   --> coalmain.c

<2025.07.23>
(12)getchar()で、改行のみを入力すると入力が終了する。
   [原因]here docでないとき(len_hd==0)も、here docのEOF判定用に入力行(改行を除く)とEOF文字列(p_hd)を
         比較しており、改行のみのときは、改行を除く入力長が0になり、この判定で、EOFになっている。
   [措置](len_hd>0 && p_hd)のときのみ、here docを判定するようにした。
   --> clfuncfile.c

<2025.08.01>
(13)CDATE('')がエラーになる。
   [原因]akxc_chk_date_type()で、日付文字列の形式を判定しているが、空文字のときは、
         '1970/01/01 00:00:00'にしていた。判定では、akxtgetwspl()を使って、年月日と時分秒を
         取り出している。空文字のときは、どちらも空文字となるはずであった。
         akxc_chk_date_type()の改修時に、サーチ位置が、対象文字列を超えるか、null終端に達したとき、
         次の開始位置(pos)が対象文字列長を超えるように+1していた。
         本ケースでは、対象文字列はnull終端であり、文字列長はINT_MAXであったため、次の開始位置が
         null終端の次になり、時分秒を取りに入ったときに、不定の文字列を取り出してしまい、この長さが
         8バイトでなかったためエラーとなっている。
   [措置]サーチ位置が、対象文字列を超えるか、null終端に達したときは、null終端に達したときでない
         場合のみposを+1するようにした。
   --> akxgetstpl.c

<2025.08.07>
(14)const x;x=0;で、定数のエラーにならない。
   [原因]cl_pr_ex_def_scalar_attr_info_posa()の中では、データタイプの指定がないために、
         pi_id='\0'で、D_AUX1_PROTECTEDを設定しているが、cl_gx_chk_vnam_info()の中で、
         cl_parm_set0()を呼んで、クリアされている。
   [措置]cl_parm_set0()を呼ぶ前に、pi_aux[1]を退避し、呼んだ後で復元するようにした。
   --> cpprdef.c

<2025.08.15>
(15)対話モードで、1つ前の入力を編集した行が、1つ前の入力の次の入力のなる。
   [原因]1つ前の入力は、treeに登録されているため、その行を編集した行は、次の入力としてtreeに
         登録される。
   [措置]編集したときは、treeをクリアする。
   --> cl_path.c

<2025.08.17>
(16)dev2環境で、標準出力のエラーメッセージが化ける。
   [原因]ログ出力で、複数I/Oに出力するときは、コード変換が1回で済むようにしたが、
         dev2環境では、ファイル出力と標準出力では、出力文字コードが異なるにも係わらず、
         ファイル出力での変換結果をそのまま標準出力に出力している。
   [措置]ファイル出力と標準出力の出力文字コードが異なるときは、それぞれでコード変換する
         ようにした。
   --> akxalog.c

<2025.08.20>
(17)loop 100000;を実行すると、「ループカウントが上限(100000)に達しました」のメッセージがでる。
   [原因]ループカウントが上限(MAX_LOOP_WHILE)に達したときに、メッセージを出している。
   [措置]loop回数に達していないという条件を追加した。
   --> cpprloop.c

<2025.08.21>
(18)'abs'.ff()(-3)が、uintで表示される。
   [原因]cl_cmpt_math()で、ABSのときは、cl_get_parm_mpa()を使って、Inforparmからデータを
         取り出しているが、iUNSIGNEDにVal1[1]を入れている。
         2025.5.7の修正以前は、cl_conv_upper2()を使って、Inforparmからデータを取り出しており、
         中でDEF_ZOK_BINAのときは、Val1[1]にiAttr[2] & AKX_NUM_Uを設定している。
   [措置]cl_get_parm_mpa()の後で、DEF_ZOK_BINAのときは、Val1[1]にiAttr[2] & AKX_NUM_U設定する
         ようにした。
   --> cl_cmpt_math.c

(19)'03-1111-2222'.'//-/';で、"-"が削除されない。
   [原因]_gx_str_rep()の中で、patに'-/'を渡され、サーチ文字列を設定しているが、サーチ文字列長の
         設定で、1を引きすぎている。
   [措置]1を引かないようにした。
   --> cl_cmpt_comp.c

<2025.08.22>
(20)defで一般変数に初期値を設定するとき、[]が複数データの扱いになり、データ並びが変数に
    設定されない。
   [原因][],{}を無条件に複数データの扱いしている。
   [措置]変数が、配列と構造体のときのみ、複数データの扱いになるようにした。
   --> cpprdef.c

<2025.08.23>
(21)リストまたはデータ並びでインデックスが範囲外でもメッセージは出るがエラー終了しない。
   [原因]cl_gx_array3()の中で、cl_gx_list_bexp()を呼び出しているが、戻り値が負のときに、
         その値を返していない。
   [措置]負のときは、値を返すようにした。
   --> cl_gx_exp_imd.c

<2025.08.24>
(22)Classのコンストラクタの中で、インスタンス変数の配列を初期値設定しようとすると、
    Myが未定義ですのエラーになる。
    array My.aa = [1,2,3];
   [原因]配列の初期値設定は、配列定義の中で行っているが、配列定義では、構造体のメンバは、
         処理しているが、インスタンス(My)は処理がない。
   [措置]cl_gx_check_define()で、変数が未定義のときは、cl_gx_get_parm_no_info()を呼ぶようにした。
   --> clprdef.c

<2025.08.25>
(23)Classのコンストラクタの中で、別クラスのインスタンスを生成しローカル変数に入れ、
    この変数をインスタンス変数のリストに追加する処理を何回か繰り返す。
    このクラスのインスタンスを作成し、リスト内のメンバ内の変数を出力すると、変数が未定義になる。
   [原因](1)コンストラクタの中で、別クラスのインスタンスを生成し、同じ変数に入れると、
            前回入れたインスタンスのprocがFree()されてしまい、リストに追加されたインスタンスの
            procが、Free()されたことになり、この中の変数が未定義になる。
         (2)最後に作成されたローカル変数は、コンストラクタの実行終了で削除されるため、
            リストに追加されたインスタンスのprocが、Free()されたことになり、この中の変数が
            未定義になる。リストには、インスタンスのガラ(InforParm)がコピーされるため、
            インスタンスは参照できる。
   [措置](1)前回入れたインスタンスのprocがFree()されないように、D_DATA_CLEAR_PROCビットを
            クリアするようにした。
         (2)リストに追加する再に、追加するインスタンスのprocがFree()されないように、
             D_DATA_CLEAR_PROCビットをクリアするようにした。
         また、Free()されなかったprocをpCLprocTable->to_free_addr(Hash)に保存し、
         セッション終了時Free()されるようにした。
   --> cl_gx_rep_prm_set.c, cl_gx_rep_set.c, clclear.c

<2025.09.05>
(24)リストまたはデータ並びにおいて、データ要素に自分自身を代入したとき、そのデータ要素に
    表示される自分自身の同じ位置の要素が不正になる。(リストまたはデータ並びは代入されるとき、
    全てがコピーされるため循環参照にはならない)
   [原因]代入処理で呼ばれるcl_gx_rep_info_set_name()の始めに、コピー先をFree()しているため、
         この時点でコピー元の該当要素のデータが未定になっているため。
   [措置]コピー先のアドレスは、最初に退避しておき、コピー先のアドレスには、ローカルエリアの
         アドレスを使う。コピー処理が終わったときに、退避しておいたコピー先アドレスに、
         ローカルエリアの内容をcl_gx_copy_info()でコピーする。
         また、コピー元が配列のときは配列が有効化どうかのチェック用の設定も行う。
   --> cl_gx_rep_prm_set.c

<2025.09.07>
(25)リストの中に配列があるとき、print /i *指定で、配列の中の表示されない。
   [原因]上記のときには、配列の定義が表示されるようになっている。
   [措置]printの表示でデータＩＤごとの処理の流れを見直した。
   --> cl_user_func.c

(26)構造体配列の未設定の配列要素に、666等を代入してもエラーにならない。
   [原因]構造体のInfoParmのD_DATA_INDEX_FREEフラグがONのときにチェックしているが、
         上記のときには、フラグがONにならない。
   [措置]上記のときに、フラグがONになるようにした。
   --> cl_gx_compile.c

<2025.09.12>
(27)配列InfoParmの親あり判定で、InfoParmが単純にコピーされただけで、親ありになる。
   [原因]InfoParmを単純コピーしただけで、InfoParmのアドレスと配列定義時に設定した
         自分自身のアドレスが異なるため、親ありとなっている。
   [措置]上記のアドレス比較に加え、単純コピーでは変わらないpIndexと子でも変わらない
         pIndex->pVarIndexも比較するようにした。
   --> cl_array.c

(28)配列の名前+[2,7]のようにして子の配列を作成したとき、設定済み要素の
    最大インデックスが変わらない。
   [原因]設定済み要素の最大インデックスを変更していない。
   [措置]マップする位置と配列の長さに合わせるようにした。
   --> cl_array.c

<2025.09.29>
(29)オプション１５の0x01(開始インデックス=1)が、配列定義時の後で設定しても機能していない。
   [原因]cl_gx_conv_index2()の中に処理がない。
   [措置]①_set_index2()で、範囲指定の次元に対応するビットを1にセットし、これをリターンし、
           pIndex->uaux2に設定する。0x01ビットが次元1に対応する。
         ②cl_gx_conv_index2()を呼ぶ前に、index_info[3]にpIndex->uaux2を設定する。
         ③cl_gx_conv_index2()の中では、このビットが1でない次元の開始インデックスが0で、
           オプション１５の0x01がオンのとき、開始インデックスを1に設定する。
   --> clprdef.c, clprdeftype.c, cl_array.c, cl_cmpt_logic.c, cl_gx_ret_set.c

<2025.10.17>
(30)mapped arrayの定義で、データエリア用のpVarIndexをMallocしている。
   [原因]mapped arrayの処理をarrayの処理に統合したときの見落とし。
   [措置]cl_pr_ex_def_array_parm()の中で、mapped arrayのときは、optにD_GX_OPT_NOALLOC_INDXを
         立てるようにした。
   --> cpprdef.c

<2025.10.18>
(31)test_print4.clを実行すると、print ttaで、 TTTのDec z[5]の後に、
    「コピー元の配列[z]が無効です。(1)」が出る。
   [原因]Dec z[5]を出力した後で、cl_array_check_valid()を呼んでいるが、その中で、親のpi_idが
         'R'でないため、エラーになっている。
         ttaのデータ型TTTのzのpi_pauxが不正な値になっているため。
         _get_def_member()で、zの定義を作成しているが、そこで使っているpInfoParmが、前の処理で
         使われており、zの定義でpi_pauxを再設定していない。
   [措置]zの定義を作成する前に、pInfoParmをクリアするようにした。
         これで直ったが、ソースを追うと、ttaを作るときには、pi_pauxにzのアドレスを設定している
         ように見えるので、なぜ、これで直ったのか不明。
   --> clprdeftype.c

<2025.10.21>
(32)PRIVATEの配列xが定義済みで、func fnの中で、LOCALの配列xを定義すると、gidにPRIVATEの値が
    設定される。
   [原因]配列定義時に、_chk_define()を呼んで、PRIVATE変数xあり、新規に定義するxはLOCALと
         なっている。この情報を呼び出し元に返すときに、argv[3]が未設定なら"LOCAL"を設定している。
         _chk_define()中では、定義済みxがないかをチェックするcl_gx_check_defin()を呼んでいて、
         argv[3]には"PRIVATE"が設定済みとなっている。
         _chk_define()から戻ったところで、既存と新規のscopeが一致しないため、新規にLOCALに、
         xを作成している。このとき、scopeにargv[3]を使っているため、gidがPRIVATEの値になっている。
   [措置]argv[3]そのままにし、argv[7]に新規定義のscopeを設定し、これを使うようにした。
   --> cpprdef.c, cpprdeftype.c

<2025.10.22>
(33)PRIVATEの配列xを関数の中で定義し、xを返却し、戻り値をprintすると、「配列は無効です。(2)」の
    エラーになる。
   [原因]cl_gx_func_method()の始めで、pInfoParmWにgidを設定しているが、cl_gx_func_mk_retval()で
         pInfoParmWが再作成され、gid消えている。
   [措置]cl_gx_func_mk_retval()を呼んだ後で、gidを再設定するようにした。また、以下を変更した。
         cl_process_return()の中で、返却値用のpInfoParmWに戻り値を設定する処理を以下とした。
         (1)クラス定義ではなくて、配列または構造体を返すときは、
            (A)ローカル変数のときは、DEF_ZOK_DATAモードのcl_gx_rep_info_als()で全てをコピーする。
            (B)その他のときは、cl_gx_copy_info()でコピーする。
         (2)その他のときは、cl_gx_rep_info_als()で通常にコピーする。
   --> cl_gx_func_bexp.c, clprret.c, cl_execute_proc.c

(34)redefine処理の_def_array()の中で落ちる。
   [原因]pIndex->pVarIndexの再取得処理で落ちている。
   [措置]redefineでは、pIndex->pVarIndexは、常にNULLなので、pIndex->pVarIndexの再取得処理を
         行わないようにした。
   --> cpprdef.c

(35)exec_all_test.clで、test_XML.clを実行すると、ファイルオープンエラーになる。
   [原因]list_test.txtの中の、「test_XML.cl '' test2.xml」を実行しているが、パラメータ設定が
         %()='',' ','test2.xml'となり、' 'でopenしている。
         akxtnsplit()の中で呼んでいるakxtgwnsl()のsepに引用符が入っていないため、引用符処理が
         正しく行われていない。
   [措置]akxtgwnsl()のsepをgsepとし、sep+"'\""を設定した。また、exec_all_test.clの中で呼んでいる
         split()の引数にオプション値:8(同じ区切り文字が連続するときは、1つにする)を設定した。
   --> akxlib.c, exec_all_test.cl

<2025.10.24>
(36)(dec)ll & 0x01で、0x01が1にならない。
   [原因]cl_cmpt_math()の中で、0x01の値をVal2[0]で取得しているが、(atr1==DEF_ZOK_BINA)のときのみ、
         演算で使用するValue1、Value2に取得した値を設定している。
   [措置]atr1とatr2を別々に設定するようにした。
   --> cl_cmpt_math.c

<2025.10.25>
(37)redefine My.sosu n;を実行すると、「cl_gx_get_info_parm_opt: [My.sosu]メンバーは指定できません。」
    のエラーが出る。
   [原因]_check_redefine()とcl_get_def_type()の処理で、My.sosuの形を想定していないため。
   [措置]両関数で、名前の中に'.'があるときは、cl_gx_expsn_obj_opt()を呼ぶようにした。
   --> clprdef.c, clprdeftype.c

<2025.10.27>
(38)クラス内の関数の中から同じクラス内の他の関数をMyを付けないと関数なしになる。
   [原因]cl_search_leaf_and_inner()の中で、一つ上を順に調べる処理を行っているが、上位の関数パスを
         作成する処理に余分(なぜ、あるかは不明)なcmpがある。
   [措置]cmp処理を削除した。
   --> cl_execute_proc.c

<2025.10.28>
(39)DECのredefineで要素数が変わらない。
   [原因]_def_array()で、前の定義と新しい定義を比較して変える必要があるかを判定しているが、
         DECのときは、preとscaのみを比較しているため、要素数が変わらなかった。
         DEC以外のときは、データサイズと要素数を比較している。
   [措置]DEC以外のときも要素数が比較されるようにした。
   --> cpprdef.c

<2025.10.31>
(40)##define M (20000) のように設定すると、「パラメータが必要です。」のエラーになる。
   [原因]置換データが'('から始まるときは、パラメータありの置換処理を行い、エラーになっている。
         _get_def_cont()の最初では、置換文字列の次の空白が残るようにスキップ処理を入れていないが、
         最後のtrimしているので、空白が消えている。
   [措置]置換データの先頭は、空白文字のときは、その次からをtrimするようにし、_rep_define_sub()
         では、置換データ中に'('があるとき、パラメータありの置換処理を行うようになっているのを
         置換データの先頭が'('のときに、パラメータありの置換処理を行うようにし、空白文字のときは、
         2バイト目からを置換データとするようにした。
   --> cllex.c

<2025.11.1>
(41)x[1..N+1]のNが##define N 100のとき、置換されない。
   [原因]置換処理のワード取り出しで'.'が区切り文字に入っていない。
   [措置]ワード取り出しに、cmpgtwdx()を使うようにした。
   --> cllex.c, clprot.h

<2025.11.7>
(42) XXX(a,b,c) から始まり、XXXがパラメータ付きの置換対象のとき、「パラメータが必要です」の
    エラーになる
   [原因]XXXがコマンドの可能性があるため、'('の前で一旦区切って、XXXのみで、kugiri処理を行う。
         kugiri処理の前に、置換処理を行うが、XXXがパラメータ付きの置換対象のときは、XXXのみの
         ため「パラメータが必要です」のエラーになっている。
   [措置]置換処理のパラメータrep_optを追加し、コマンドのときは、rep_opt=1として、エラーにしない
         ようにした。
   --> cllex.c

<2025.11.9>
(43)パラメータ付きの置換で、置換された中に、さらに置換があると、元のラインデータを一部が
    上書きされる。
   [原因]置換されたものを再帰的に置換しているが、置換文字列長が元より大きいときの挿入処理に
         不具合がある。
   [措置]置換処理を以下のように変更した。
         (1)wkstrに、データを入れ始める直前の状態(括弧対検査用の変数の値等)を保存する
         (2)再帰処理を止め、1置換毎に、置換対象文字列の開始位置から再度、構文解析を再開する。
         (3)置換後、括弧対検査用の変数の値等を戻し、構文解析を再開する。
   --> cllex.c

<2025.11.12>
(44)procの中で、構造体配列を定義すると、エラーになる。定義するときに、private,static等を
    付けるとエラーにならない。
   [原因]iParm[0]=23,iParm[1]=0でcl_get_def_alsize()を呼び出し、エラーになっている。
         procの中で、private,static等が付いているときは、定義文としてcl_pr_ex_def_array()を
         呼び出し、これが、i_parm=NULL で、cl_pr_ex_def_array_parm()を呼び出している。
         一方、private,static等がないときは、型定義があれば、この情報をi_parmに設定して、
         cl_pr_ex_def_array_parm()を呼び出している。
         cl_pr_ex_def_array_parm()では、最初の属性取得で、デフォルトでiParm[1]=sizeof(char *)
         としており、i_parm=NULLのときは、これが、それ以降変わらないが、i_parm<>NULLのときは、
         i_parmでiParmを上書きする。i_parm[0]=0,i_parm[1]=0のため、iParm[1]=0となっている。
   [措置]型定義取得(cl_get_def_type())の中で、型定義のときは、iParm[1]=sizeof(char *)とした。
   --> cpprdeftype.c

<2025.11.13>
(45)##if 0 等で、それ以降に、##defineがあるとskip処理が中断する。
   [原因]skip処理の中で、##等で始まる行があると、そこでskip処理を抜けている。
         また、include、resume処理で、ifnest_cnt,ifnest[],iftrue[]を保存、復旧していない;
   [措置](1)skip処理の中で、ifdef,ifndef,if,elif,else,endif,elifdef,elifndefのときのみ、
            skip処理を抜けるようにした。
         (2)include、resume処理で、ifnest_cnt,ifnest[],iftrue[]を保存、復旧するようにした。
   --> cllex.c

<2025.11.18>
(46)関数の中で作成したローカルの配列をprive変数xpに代入し、それをreturnすると、
    返却用変数(関数名nnnn)の表示が不正になる。
   [原因]ローカルの配列が削除されたため。
   [措置]配列または構造体において、親があり親がローカル変数のときは、実体をコピーしたものを
         返すようにした。また、ローカル変数をreturnするときも実体をコピーしたものを返すようにした。
   --> clprret.c

(47)関数の中で作成したローカルの構造体xをprive変数xpに代入し、関数から帰ったところでxpを
    printすると、表示が不正になる。
   [原因]構造体xが削除されているため。
   [措置]配列と同様に有効性をチェックするようにした。
   --> clprdeftype.c, cl_user_func.c

<2025.11.24>
(48)bexp x = e IN b c;を実行すると、「 m()は指定できません。」のエラーになる。
   [原因]cl_gx_bexp()の中で、prmpをppParmに変換し、cl_gx_bexp2()を呼び出している。
         cl_gx_bexp2()の中で、cl_cmpt_comp()を呼び出すときには、prmpをNULLにしているが、
         cl_cmpt_comp()の中で、INの処理を行うときに、cをppParmに変換するためにprmpを使っている。
   [措置]cl_cmpt_comp()にnparmとprmpを渡すのを止め、INとiINは、cl_gx_bexp2()の中で、
         cl_gx_func_bexp()を呼ぶようにした。
   --> cl_cmpt_comp.c, cl_gx_compute.c, clfunc.c, cl_gx_rep_set.c, cl_proc_bexp.c

(49)$$%(1)や$%(1)が、$1の値になる。
   [原因]組み込み関数呼び出しの引数を整理した再に、cl_func_conv_parm()にpOperatorが
        渡らなくなったため。
   [措置]まず、arg_kbnの21,22の実装が誤っていたため以下に変更。
         arg_kbn=21 ==> arg_kbn=20,ret_kbn=2
         arg_kbn=22 ==> arg_kbn=20,ret_kbn=3
         その上で、arg_kbn=21でpOperatorを渡すようにした。
   --> cl_gx_func_bexp.c, clfunc.c

<2025.11.25>
(50)exec_all_test.clで、test_split.cl '' '' 2 を実行すると、数字以外の文字"'"があるの
    エラーになる。
   [原因]%1,%2が"''"になっている。split()でオプションを指定していないため。
   [措置]引用符を削除する0xc0を指定して。また、akxtnsplit()では、optに0x80が指定されたら、
         0x40を自動で立てるようにした。
   --> axlib.c, exec_all_test.cl

(51)sample_kojin.clを実行すると、f = family[j++];で、「構造体は無効です(2)」のエラーになる。
   [原因]family_tab[2]に初期値を設定する処理(cl_set_array_ix2())で、以下があり、
         pInfoParmW->pi_hlen = ppParm[0]->pi_hlen; <== これが何をやっているかは、忘れた。
         pInfoParmW->pi_hlenがクリアされている。
   [措置]pInfoParmW->pi_hlenを再設定するようにした。
   --> cl_gx_rep_set.c

(52)exec_all_test.clで、test_XML.cl '' test2.xml を実行すると、ファイルオープンエラーになる。
   [原因]No.50と同じ。
   [措置]
   --> 

<2025.12.03>
(53)/tmp/coal_new/src/appl/coal/testでcoal_nのみを実行しても何も出力されない。
   [原因]cl_getenv()でakb.iniを読んでプログラム名のセクションをサーチしているが、ないときに
         -1でリターンして、エラー終了している。
   [措置]上記のときは、-100を返すようにした。
   --> akbname.c

<2025.12.09>
(54)define optionの設定が、それ以降のcl_lex()で解析に反映されない。
   [原因]cl_lex()で、define option/optionsコマンドのtreeを作成するときに、optionを
         設定しているが、cl_lex()では、スクリプト解析前に、optionを取り込んでいるので、
         途中の解析には反映されていない。
   [措置](コマンドのkugiri処理終了時に、処理したコマンドが、define option/optionsのときは、
         optionを取り込み直すようにした。)
         上記は、判定にコストがかかるので、区切り文字が';'のときは、無条件にoptionを
         取り込み直すようにした。
   --> cllex.c

<2025.12.19>
(55)ブロック処理から抜けたときに、ブロック構造体でFree()されていない変数がある。
   [原因]見落とし。
   [措置]cl_reset_block_cb()を作成した。
   --> cl_if_pre_proc.c, cpprloop.c, cl_process_end_if.c, cl_prot.h

<2025.12.21>
(56)連想配列のデータにnull文字列を設定し、集合演算で作成した配列要素がMallocされていない
    null文字列データにも係わらず、Mallocされたフラグが立ち、Mallocされていないエラーが出る。
   [原因]_gx_rep_all_hash()の中で要素をコピーした再に、_gx_rep_set_sca_im()を呼んで、
         Mallocされたフラグが立っている。
   [措置]コピー元が、Mallocされていないnull文字列データかどうかを判定する関数を作成し、
         そうでないときのみ_gx_rep_set_sca_im()を呼ぶようにした。
         _gx_rep_all_array()も同様とした。
        (注)配列要素をコピーする関数の中で、当該要素のコピー処理では、Mallocしたときのみ
            _gx_rep_set_sca_im()を呼んでいるので、コピーする関数からリターンした後で、
            _gx_rep_set_sca_im()を呼ぶ処理は不要と思われるが、コピー関数で別ルートで処理
            されることもあるので、このままとした。
   --> cl_gx_rep_prm_set.c

<2025.12.23>
(56)"if leng(%1)<8 || !(%1 is 'N') then"を実行するとエラーになる。
   [原因]tree作成処理の中で、"is"の文字列演算子(mc=1000+x)を処理対象外としてエラーにしている。
   [措置]mc>=1000のときは、２項演算子として処理するようにした。
   --> cl_gx_tree.c

<2025.12.25>
(57)define mappedarray %m "" 10;を実行すると、""の部分が無視される。
   [原因]cmd->parl[0]作成されたコマンドラインを実行するようになっているが、cmd->parl[0]を
         作成するときに、len=0だと、空文字になってしまいコマンドラインから消えている。
   [措置]上記でlen=0のときは、"NULL"を設定するようにした。cl_tr_gather()も同様にした。
   --> cllex.c, cltrbexp.c

<2025.XX.XX>
(58)
   [原因]
   [措置]
   --> 

