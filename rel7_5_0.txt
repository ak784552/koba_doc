coal 7.5.0の機能改善およびバグｆｉｘ
********************************
*         機 能 改 善          *
********************************
<2025.03.24>
(1)有理数をサポートした。
   --> makefile, cl_cmpt_rational.c, cl_cmpt_math.c, cl_gx_func_bexp.c, clprdeftype.c,
       cltrbexp.c, cl_conv_const_n.c, clconst.h

<2025.03.25>
(2)m_is_mpa1(), m_mod2()を追加した。
   --> akxmpa.c, akxlib.h

<2025.03.26>
(3)akxg_sosu_next(), akxg_sosu_next_tbl()を追加した
   --> akxgmath.c, akxlib.h

<2025.04.12>
(4)_b_search_mpa(), akxg_sosu_over_by_tbl(), akxg_sosu_chk_mpa_by_tbl(),akxg_sosu_next_mpa_tbl(),
   akxg_sosu_next_mpa(), akxg_sosu_over_mpa_by_tbl()を追加した
   --> akxgmath.c, akxlib.h

<2025.05.19>
(5)_cvl()のオーバーフローチェックに、INTベースオプションを追加した。
   -->akxconvn.c, cl_conv_const_n.c

<2025.05.20>
(6)64ビット環境では、intオーバーのときは、longに変更するようにした。
   このために、_cvl()のINTベースオプションは、なしに戻し、intオーバーのチェックとlongへの変更は、
   cl_cvn10()で行うようにした。
   -->akxconvn.c, cl_conv_const_n.c

(7)64ビット環境では、型指定なしのint/uint変数を"++"したときに、オーバーフローのときは、
   long/ulongに変更するようにした。
   --> cl_gx_compute.c

<2025.05.27>
(8)会話モードでのサブコマンドを以下のように見直した。
   /treeを廃止し、/のみのときは、前回の実行を再度実行するようにした。また、/ historyのときは、
   入力履歴域に保存された文からコマンドtreeを生成し直し、実行するようにした。
   --> cl_path.c

<2025.06.08>
(9)m_normalize10()とm10w_print_debug()を追加した。
   --> akxmpa.c

<2025.06.09>
(10)プリントオプション(flgs)を引数で渡していない関数でのデータ出力については、一時的に、
   実行時オプションを設定してプリントオプションを効かせていたが、引数(opt_edit)で渡すようにした。
   また、プリントフォーマットの%rでもプリントオプションが効くようにした。
   --> cl_user_func.c, cl_cmpt_string.c, cl_func_file.c, cl_const.h

(11)[f]putline()で、区切り文字オプションを有効にしたときは、その文字で区切られるようにした。
    区切り文字のデフォルトを/cとした。
    また、データ指定範囲データが展開されるようにした。
   --> cl_func_file.c

<2025.06.12>
(12)parm_to_char()の*p1とp1_lenの扱いを解り易くした。
    また、parm_to_char2(),parm_to_char2_opt_edit(),cl_get_info_str()の引数にp1_lenを追加した。
   --> cl_cmpt_string.c

<2025.06.13>
(13)プリントオプションの'/'から始まる設定を繰り返し指定できるようにした。
   --> cl_user_func.c

<2025.06.18>
(14)cl_set_array()で、配列、リスト、データ並びのデータ指定を可能とし、名前付き引数MAX_LAYERを
    設定した。
    また、cl_set_array_ix()をcl_set_array_ix2()として、出力と入力のppParm[]を分けた。
   --> cl_gx_ret_set.c, cl_gx_rep_prm_set.c

<2025.06.22>
(15)ハッシュ関数に、キー値を前方一致で検索する関数(akxs_xhashn2_like)を追加した。
    また、登録位置を指定してキーを削除する機能('E')を追加した。
   --> akxshash.c

<2025.06.25>
(16)ISに'C'(文字コード)を、TOに'CN'(文字コードの名称に変換)を追加した。
   --> cl_cmpt_is.c, cl_cmpt_to.c

<2025.06.26>
(17)akxs_ino_mem_opt()のoptがcode_typeのみの高速版(akxs_in_mem_type())を追加した。
   --> akxstring.c

<2025.06.27>
(18)akxs_ino_mem_opt()で、targetが長いと遅くなる原因がakxmbncmp_type_opt()で、akxqmlen_type()を
    呼んでいることが判明したため、akxmbncmp_type_opt()を文字数も渡すakxmbncmp_type_opt_m()にし、
    akxs_ino_mem_opt()では、mtarとmstrも渡すようにした。
    また、akxs_in_mem_type()を使わなくても良くなった。
   --> akxstring.c

<2025.06.28>
(19)以下のように、組み込み関数の最大パラメータ数をチェックできるようにした。
    pot->resv>0のときに、pot->resv-1を最大パラメータ数としてチェックする。
   --> cl_gx_func_bexp.c

<2025.07.04>
(20)比較文字列を内側で回す文字サーチ関数(akxs_in_mem_str_inner())を追加し、
    (opt & 0x80)がONのときは、akxs_in_mem_str()を呼ぶようにした。逆に、
    akxs_in_mem_str()は、(opt & 0x80)がONのときは、akxs_in_mem_str_inner()を呼ぶようにした。
   --> akxstring.c

(21)関数INSTRCHARS()を追加した。
   --> cl_cmpt_comp.c, clprot.h

(22)akxs_in_mem_str()では、大文字小文字無視、半角全角無視の比較は、akxmbncmp_type_opt_m()の
    中で行っているが、対象文字列を1文字ずらす度に対象文字列に対して、最長比較文字列の文字数分の
    変換を行っているため、変換の効率が悪い。
    そこで、akxmbncmp_type_opt_m()では、変換しないことにし、akxs_in_mem_str()で、最初に、
    比較文字列と対象文字列の先頭の比較文字列数分を変換しておき、後は、1文字ずらす度に、
    比較文字数分が変換されているように、比較文字数分の次の文字のみを変換するようにした。
    これでも、1文字ずらすために、半角全角変換が必要なため、半角全角変換は2回行われる。
   --> akxstring.c, akxcode.c, akxlib.h

<2025.07.05>
(23)以下により、全角変換と大文字変換の回数を文字数分の1回にした。
    ・半角全角無視で対象文字列に半角カナの濁点、半濁点がない用の関数
      akxs_ino_mem_opt_no_kanad()を作成した。(大文字小文字無視もこれで実行する))
    ・akxs_ino_mem_opt()では、上記以外で、変換があるときは、最初に、対象文字列と比較文字列の
      両方を変換済みにした。
   --> akxstring.c, akxlib.h

<2025.07.13>
(24)for to stepの構文で、stepの後ろのパラメータがなくても多くてもエラーを出すようにした。
   --> cltrloop.c

<2025.07.15>
(25)組み込み関数実行前のNULLチェックで、エラーメッセージを出すようにした。
    _get_array_info_ref()の最初で、NULLパラメータとNULL値のときは、エラーとした。
   --> cl_gx_func_bexp.c, cl_gx_rep_set.c

<2025.07.16>
(26)ARRAYCLR()等で、A,R以外のチェックが、cl_get_array_index_tbl_ref()の中で呼んでいる
    cl_get_parm_bin()まで行われていないので、cl_array_ope_opt()で行われるように以下のように
    修正した。
    ・ARRAYCMP()は、ok_opt=0x02 | 0x08 | 0x1000
    ・他は、ok_opt=0x02
   --> cl_gx_rep_set.c

<2025.07.19>
(27)以下のように関数名を変更した。また、cl_is_null()を追加した。
   --> cl_null_data()        ==> cl_null_char()
       cl_is_null_data_sub() ==> cl_is_null_char_sub()
       cl_is_null_data()     ==> cl_is_null_char()

<2025.07.22>
(28)cl_is_null()では、オプション１が0x40のときは、cl_is_null_chk_parm()を呼んで、NULL_PARMと
    NULL_CHARのときに、NULL値と判定していた(NULL値の判定がない)が、オプション１に0x80を追加し、
    cl_is_null_chk_parm()を使用しないで、cl_is_null()の中で、判定するようにした。
   --> clfunc.c

<2025.07.29>
(29)akxtgwnsl()で、opt=0x1000のときは、引用符で始まらないワード中の引用符を区切りとしないようにした。
   --> akxlib.c

<2025.08.07>
(30)システム変数に、TRUEとFALSEを追加した。
   --> cl_conv_sysvar.c, clglobal.c, clconst.h

(31)「定数(x)への代入はできません。」のエラーメッセージで、システム変数のときは、
    「システム変数(x)への代入はできません。」とした。
   --> cl_gx_compile.c, clmessage.c

<2025.08.09>
(32)オプション２４=0x100のときは、システム変数の予約語チェックでは、大文字小文字を
    問わないようにした。
   --> cl_anal_parm.c, cl_conv_parm

<2025.08.14>
(33)全角半角変換で"＼"を"\"に変換するようにした。
   --> akxcode.c

<2025.08.15>
(34)ログ出力で、複数I/Oに出力するときは、コード変換が1回で済むようにした。
   --> akxalog.c

<2025.08.16>
(35)DEFINEで、複数データを設定するとき、"{}"でも良いようにした。
   --> clprdef.c

<2025.08.22>
(36)length()で、配列、リスト、データ並びのときは、要素数を返すようにした。
   --> cl_cmpt_is.c

(37)concat()関数で、連結する文字列の間に挿入する文字列を指定する SEP==>'xxx' を追加した。
    それに伴い、concat2(),cl_gx_bexp2()を作成し、引数をppParm[]ベースに変更した。
    また、cl_cmpt_string())の引数をppParm[]ベースに変更した。
   --> cl_cmpt_string.c, cl_gx_compute.c, cl_gx_func_bexp.c

(38)リスト、データ並びにインデックス参照のとき、負のときは、末尾からの指定とした。
   --> cl_gx_rep_set.c, cl_gx_exp_imd.c

(39)countv()関数で、opt=0x02のときは、配列の定義長を返すようにした。
   --> clfunc.c

<2025.08.24>
(40)POP()関数を追加した。
   --> clconst.h, cl_gx_func_bexp.c, cl_gc_ret_set.c

<2025.08.25>
(41)RANDOM()関数を追加した。
   --> clconst.h, cl_gx_func_bexp.c, cl_gc_ret_set.c

<2025.08.29>
(42)集約の'|'、'&'、'^'の結果がユニークになるようにした。
    また、'-'と'+'に同じ機能で、結果がユニークになる演算子'/'と'*'を追加した。
   --> cl_cmpt_logic.c, cl_gx_rep_prm_set.c

<2025.09.06>
(43)POP()関数の引数に、POPする数、間隔、名前付きOPTを追加した。
   --> cl_gx_rep_sep.c

<2025.09.15>
(44)親の設定済み最大インデックス位置を子に反映させる関数ADJUST()を追加した。
   --> cl_gx_func_bexp.c, cl_cmpt_logic.c, clconst.h

<2025.XX.XX>
(45)
   -->

********************************
*           Bug fix            *
********************************
<2025.03.26>
(1)3.5r/10が、「１０進小数点数[3.5r]の指定が誤っています(rc=-15)。」となる。
   [原因]atrが2と4のときは、ULIRを返しているが、3.5のときは、atr=8となっているため、
         UILRが返っていない。
   [措置]atr=8でもULIRを返すようにした。
   --> akxconv.c

<2025.04.10>
(2)a=32767.0;b=16384.0;a/b が 1.0... になる。
   [原因]1桁目を処理した後、a=16383.0で、anm=163 bnm=163 となっているため、anmが16383にならず、
         また、d=1となるため、md[d]がそのまま使われ、正しい引き算になっていなかった。
   [措置]anm=bnmでもanmが16383になるようにし、d=100(RADIX)のときは、d=99(RADIX-1)とするようにした。
   --> akxmpa.c

<2025.04.23>
(3){}の形式の関数を実行したとき、retvalに設定してあるpInfoParmWの内容がRETURN時に不正になる。
   [原因]pInfoParmWはオート変数を使っているため、関数実行でnodeに戻る場合、エリアが失われてしまう。
         {}形式でないときは、pInfoParmWをmallocしたものに置き換えているため、エリアが失われることはない。
   [措置]{}の形式かどうかの判別をやめ、pInfoParmWをmallocしたものに置き換える処理を関数化した上で、
         ユーザ定義関数を実行するときのみ、この関数を呼ぶようにした。
         なお、cl_gx_func_method()の中では、pInfoParmW->pi_idに'F'をセットし、このときのみ、
         上記関数を実行するようにした。
      /************ retvalは関数からreturnするときのみ使用するため、これは必要ない気がする
         また、上記関数では、pInfoParmWのエリア用に"$関数名"の変数を作成しているが、この変数の
         後ろに通番を付けるようにした。これは、一つの式の中で同じ関数が呼ばれても、pInfoParmWの
         エリアが同じにならないようにするためである。
       ************/
   --> cl_gx_func_bexp.c, cl_execute_proc.c

<2025.05.12>
(4)オプション20で仮数桁数とゼロサプレスを指定してもdouble型のときは、0.0がゼロサプレスされない。
   [原因]仮数桁数が指定なしでゼロサプレス指定があるとき、0.0を"0.0"としている。
   [措置]ゼロサプレス指定があるときは、0.0を"0.0"とするようにした。
   --> cl_cmpt_string.c

<2025.05.14>
(5)coal_clasicで、test_math.clを実行すると、print "30 ** 9" が、"演算子30が誤っている"の
   エラーになる。
   [原因]パラメータが1つのときは、cl_getitems()を使って、項目に分解しているが、項目データを
         格納するエリアworkの長さをパラメータ長(len)+1にしている。
         cl_getitems()では、項目データをnull終端にして、workに詰めている。このとき、akxtgwnsl()、
         この中で呼んでいるakxwdmax_chkm()を使って、項目の分解とworkへの設定を行っている。
         このケースでは、"9"を取りに行ったときには、akxwdmax_chkm()の引数は、lmax=1,l=0,m=1で
         エリアが足りているかの判定を"(l<lmax-m)"としているため、"9"が設定されていない。
         結果として項目数が２となり、30が単項演算子と見なされエラーとなった。
   [措置]akxwdmax_chkm()判定を"(l+m <= lmax)"とした。akxwdmax_chk()、akxwdmax_chk2()も同様に修正。
   --> akxgetstpl.c

<2025.05.19>
(6)型指定なしの整数変数の"++"、"--"で、オーバーフローしても、元の値のままになる。
   [原因]オーバーフローするときは、演算していない。
   [措置]オーバーフローしたときは、DECに変換するようにした。また、オプションも考慮するようにした。
   --> cl_gx_compute.c

<2025.05.20>
(7)64ビット環境では、型指定uint属性のUINT_MAX値を"++"すると0になる。
   [原因]uintをulongにして"++"しているが、uintに戻すときに、cl_set_parm_bin()を使い、ulong値を
         そのまま渡している。cl_set_parm_bin()は、int値をもらう定義のため、下位32ビットが取られ、
         0となった(ulong値が0x0000000100000000となっているため)。
   [措置]int変数に代入してから、cl_set_parm_int()を呼ぶようにした。
         また、cl_set_parm_int()では、long値に代入して、cl_set_parm_long()を呼ぶようになっていたが、
         long値の前半分にint値が入るようにした。
   --> cl_gx_compute.c cl_conv_const_n.c

<2025.06.11>
(8)parm_to_char(),parm_to_char_temp()を呼ぶ前に、文字列を戻すポインタ(p1)を初期化していないヶ所がある。
   [原因]設定忘れ。
   [措置]p1 = NULLを入れた。
   --> cl_conv_arg.c, cl_gx_compute.c, cl_cmpt_comp.c, clprdef.c, cl_cmpt_to.c, cl_cmpt_string.c

<2025.06.13>
(9)--p1,1で、lprint()を実行してもPRINTOUT()の形式で出力されない。
   [原因]cl_func_print()で処理しているが、D_FUC_FPRINT以外は、D_FUC_ELWRITE1で出力しており、
         PRINTOUT(),ERROUT()を呼ぶ処理がない。
   [措置]cl_func_print()の最初で、PRINTオプション(flgs)の処理をしているが、_func_print_sub()に
         渡しておらず、_func_print_sub()では、flgsの処理を独自で行っているため、flgsの初期化を
         cl_func_print()に移し、_func_print_sub()に渡すようにした。
         その上で、PRINTOUT(),ERROUT()を呼ぶ処理を追加した。
         また、_func_print_sub()は、cl_func_sprint()でも呼んでいるため、flgsの処理を同様にした。
   --> cl_user_func.c

<2025.06.22>
(10)array b 10 = a[2..5]; の後で、print b; print *b を実行すると、aは無効にならないが、
    print b *b;を実行すると、aが無効のエラーになる。
   [原因]配列の範囲指定インデックスでは、temp域に配列定義とデータを作成しており、その行の実行が
         終わるとtemp域は、無効になるが、printで、この配列の有効性をチェックしたときのtemp域の
         内容により無効になったり有効になったりしている。
/**********************************************************************************************
   [措置]配列定義を保存する変数をローカルに作成し、temp域が無効になっても、配列定義を参照できる
         ようにした。
         そして、この行の実行が終わって次の行を実行するときに、この配列定義のpi_idをクリアして、
         無効判定になるようにした。このときに、この変数を削除するために、ハッシュ関数に、'E'を
         追加したが、配列定義域がfree()されるため、変数は削除できない。
   --> cl_array.c, clnode.c
**********************************************************************************************/
   [措置]配列の範囲指定インデックスで取得したデータを保存する配列を通常のローカル変数で
         作成し、配列が無効にならないようにした。
         変数名は、"$$range_array%08x"、%08xは、インデックス情報(tdtArrayIndex)のアドレス。
   --> cl_array.c

<2025.07.19>
(11)コマンドライン オプション -oで、n=xxxxでない指定をすると値が設定されない。
   [原因]set_dbgopt_argv()で、n=xxxxでないときに、iADD_DELが未設定のまま、set_flg[ii]に代入している。
   [措置]iADD_DEL = cl_get_add_del(&p,&len);を追加した。
   --> coalmain.c

<2025.07.23>
(12)getchar()で、改行のみを入力すると入力が終了する。
   [原因]here docでないとき(len_hd==0)も、here docのEOF判定用に入力行(改行を除く)とEOF文字列(p_hd)を
         比較しており、改行のみのときは、改行を除く入力長が0になり、この判定で、EOFになっている。
   [措置](len_hd>0 && p_hd)のときのみ、here docを判定するようにした。
   --> clfuncfile.c

<2025.08.01>
(13)CDATE('')がエラーになる。
   [原因]akxc_chk_date_type()で、日付文字列の形式を判定しているが、空文字のときは、
         '1970/01/01 00:00:00'にしていた。判定では、akxtgetwspl()を使って、年月日と時分秒を
         取り出している。空文字のときは、どちらも空文字となるはずであった。
         akxc_chk_date_type()の改修時に、サーチ位置が、対象文字列を超えるか、null終端に達したとき、
         次の開始位置(pos)が対象文字列長を超えるように+1していた。
         本ケースでは、対象文字列はnull終端であり、文字列長はINT_MAXであったため、次の開始位置が
         null終端の次になり、時分秒を取りに入ったときに、不定の文字列を取り出してしまい、この長さが
         8バイトでなかったためエラーとなっている。
   [措置]サーチ位置が、対象文字列を超えるか、null終端に達したときは、null終端に達したときでない
         場合のみposを+1するようにした。
   --> akxgetstpl.c

<2025.08.07>
(14)const x;x=0;で、定数のエラーにならない。
   [原因]cl_pr_ex_def_scalar_attr_info_posa()の中では、データタイプの指定がないために、
         pi_id='\0'で、D_AUX1_PROTECTEDを設定しているが、cl_gx_chk_vnam_info()の中で、
         cl_parm_set0()を呼んで、クリアされている。
   [措置]cl_parm_set0()を呼ぶ前に、pi_aux[1]を退避し、呼んだ後で復元するようにした。
   --> cpprdef.c

<2025.08.15>
(15)対話モードで、1つ前の入力を編集した行が、1つ前の入力の次の入力のなる。
   [原因]1つ前の入力は、treeに登録されているため、その行を編集した行は、次の入力としてtreeに
         登録される。
   [措置]編集したときは、treeをクリアする。
   --> cl_path.c

<2025.08.17>
(16)dev2環境で、標準出力のエラーメッセージが化ける。
   [原因]ログ出力で、複数I/Oに出力するときは、コード変換が1回で済むようにしたが、
         dev2環境では、ファイル出力と標準出力では、出力文字コードが異なるにも係わらず、
         ファイル出力での変換結果をそのまま標準出力に出力している。
   [措置]ファイル出力と標準出力の出力文字コードが異なるときは、それぞれでコード変換する
         ようにした。
   --> akxalog.c

<2025.08.20>
(17)loop 100000;を実行すると、「ループカウントが上限(100000)に達しました」のメッセージがでる。
   [原因]ループカウントが上限(MAX_LOOP_WHILE)に達したときに、メッセージを出している。
   [措置]loop回数に達していないという条件を追加した。
   --> cpprloop.c

<2025.08.21>
(18)'abs'.ff()(-3)が、uintで表示される。
   [原因]cl_cmpt_math()で、ABSのときは、cl_get_parm_mpa()を使って、Inforparmからデータを
         取り出しているが、iUNSIGNEDにVal1[1]を入れている。
         2025.5.7の修正以前は、cl_conv_upper2()を使って、Inforparmからデータを取り出しており、
         中でDEF_ZOK_BINAのときは、Val1[1]にiAttr[2] & AKX_NUM_Uを設定している。
   [措置]cl_get_parm_mpa()の後で、DEF_ZOK_BINAのときは、Val1[1]にiAttr[2] & AKX_NUM_U設定する
         ようにした。
   --> cl_cmpt_math.c

(19)'03-1111-2222'.'//-/';で、"-"が削除されない。
   [原因]_gx_str_rep()の中で、patに'-/'を渡され、サーチ文字列を設定しているが、サーチ文字列長の
         設定で、1を引きすぎている。
   [措置]1を引かないようにした。
   --> cl_cmpt_comp.c

<2025.08.22>
(20)defで一般変数に初期値を設定するとき、[]が複数データの扱いになり、データ並びが変数に
    設定されない。
   [原因][],{}を無条件に複数データの扱いしている。
   [措置]変数が、配列と構造体のときのみ、複数データの扱いになるようにした。
   --> cpprdef.c

<2025.08.23>
(21)リストまたはデータ並びでインデックスが範囲外でもメッセージは出るがエラー終了しない。
   [原因]cl_gx_array3()の中で、cl_gx_list_bexp()を呼び出しているが、戻り値が負のときに、
         その値を返していない。
   [措置]負のときは、値を返すようにした。
   --> cl_gx_exp_imd.c

<2025.08.24>
(22)Classのコンストラクタの中で、インスタンス変数の配列を初期値設定しようとすると、
    Myが未定義ですのエラーになる。
    array My.aa = [1,2,3];
   [原因]配列の初期値設定は、配列定義の中で行っているが、配列定義では、構造体のメンバは、
         処理しているが、インスタンス(My)は処理がない。
   [措置]cl_gx_check_define()で、変数が未定義のときは、cl_gx_get_parm_no_info()を呼ぶようにした。
   --> clprdef.c

<2025.08.25>
(23)Classのコンストラクタの中で、別クラスのインスタンスを生成しローカル変数に入れ、
    この変数をインスタンス変数のリストに追加する処理を何回か繰り返す。
    このクラスのインスタンスを作成し、リスト内のメンバ内の変数を出力すると、変数が未定義になる。
   [原因](1)コンストラクタの中で、別クラスのインスタンスを生成し、同じ変数に入れると、
            前回入れたインスタンスのprocがFree()されてしまい、リストに追加されたインスタンスの
            procが、Free()されたことになり、この中の変数が未定義になる。
         (2)最後に作成されたローカル変数は、コンストラクタの実行終了で削除されるため、
            リストに追加されたインスタンスのprocが、Free()されたことになり、この中の変数が
            未定義になる。リストには、インスタンスのガラ(InforParm)がコピーされるため、
            インスタンスは参照できる。
   [措置](1)前回入れたインスタンスのprocがFree()されないように、D_DATA_CLEAR_PROCビットを
            クリアするようにした。
         (2)リストに追加する再に、追加するインスタンスのprocがFree()されないように、
             D_DATA_CLEAR_PROCビットをクリアするようにした。
         また、Free()されなかったprocをpCLprocTable->to_free_addr(Hash)に保存し、
         セッション終了時Free()されるようにした。
   --> cl_gx_rep_prm_set.c, cl_gx_rep_set.c, clclear.c

<2025.09.05>
(24)リストまたはデータ並びにおいて、データ要素に自分自身を代入したとき、そのデータ要素に
    表示される自分自身の同じ位置の要素が不正になる。(リストまたはデータ並びは代入されるとき、
    全てがコピーされるため循環参照にはならない)
   [原因]代入処理で呼ばれるcl_gx_rep_info_set_name()の始めに、コピー先をFree()しているため、
         この時点でコピー元の該当要素のデータが未定になっているため。
   [措置]コピー先のアドレスは、最初に退避しておき、コピー先のアドレスには、ローカルエリアの
         アドレスを使う。コピー処理が終わったときに、退避しておいたコピー先アドレスに、
         ローカルエリアの内容をcl_gx_copy_info()でコピーする。
         また、コピー元が配列のときは配列が有効化どうかのチェック用の設定も行う。
   --> cl_gx_rep_prm_set.c

<2025.09.07>
(25)リストの中に配列があるとき、print /i *指定で、配列の中の表示されない。
   [原因]上記のときには、配列の定義が表示されるようになっている。
   [措置]printの表示でデータＩＤごとの処理の流れを見直した。
   --> cl_user_func.c

(26)構造体配列の未設定の配列要素に、666等を代入してもエラーにならない。
   [原因]構造体のInfoParmのD_DATA_INDEX_FREEフラグがONのときにチェックしているが、
         上記のときには、フラグがONにならない。
   [措置]上記のときに、フラグがONになるようにした。
   --> cl_gx_compile.c

<2025.09.12>
(27)配列InfoParmの親あり判定で、InfoParmが単純にコピーされただけで、親ありになる。
   [原因]InfoParmを単純コピーしただけで、InfoParmのアドレスと配列定義時に設定した
         自分自身のアドレスが異なるため、親ありとなっている。
   [措置]上記のアドレス比較に加え、単純コピーでは変わらないpIndexと子でも変わらない
         pIndex->pVarIndexも比較するようにした。
   --> cl_array.c

(28)配列の名前+[2,7]のようにして子の配列を作成したとき、設定済み要素の
    最大インデックスが変わらない。
   [原因]設定済み要素の最大インデックスを変更していない。
   [措置]マップする位置と配列の長さに合わせるようにした。
   --> cl_array.c

<2025.XX.XX>
(29)
   [原因]
   [措置]
   --> 

